function setupRouteIcons(n, t, i, r) { let u = L.icon({ iconUrl: "/images/map/startIcon.svg", iconSize: [32, 37], iconAnchor: [1, 37], popupAnchor: [5, -28] }), f = L.marker(n, { icon: u }).bindPopup("Start Location"), e = L.icon({ iconUrl: "/images/map/finishIcon.svg", iconSize: [32, 37], iconAnchor: [1, 37], popupAnchor: [5, -28] }), o = L.marker(t, { icon: e }).bindPopup("Finish Location"); r.addLayer(f); r.addLayer(o); editableLayers.addLayer(r); map.fitBounds(i.getBounds()) } function drawImportedRoute(n) { editableLayers.eachLayer(function (n) { editableLayers.removeLayer(n) }); isUploadButtonClicked = !0; importedRouteTotalLength = 0; minAltitude = 0; maxAltitude = 0; importedRoutePoints.length = 0; yAxisChartData.length = 0; xAxisChartData.length = 0; altitudes.length = 0; let f = L.layerGroup(), i = []; for (let t = 0; t < n.length; t++) { let r = n[t]; i.push(new L.LatLng(r[0], r[1], r[2])); let u = r[2].toFixed(2); altitudes.push(u); n.length < 1500 ? yAxisChartData.push(u) : t % 250 == 0 && yAxisChartData.push(u) } minAltitude = Math.min(...altitudes); maxAltitude = Math.max(...altitudes); let r = new L.Polyline(i, { color: "#c700ac", weight: 4, smoothFactor: 1, fillOpacity: .5 }); importedRoutePoints = r.getLatLngs().map(n => [n.lat, n.lng, n.alt]); let t = r.getLatLngs(); for (let n = 0; n < t.length - 1; n++)importedRouteTotalLength += t[n].distanceTo(t[n + 1]); let u = 0; for (let n = 0; n < t.length - 1; n++)u += t[n].distanceTo(t[n + 1]), t.length < 1500 ? xAxisChartData.push(`${(u / 1e3).toFixed(2)} km`) : n % 250 == 0 && xAxisChartData.push(`${(u / 1e3).toFixed(2)} km`); importedRouteTotalLength /= 1e3; r.bindPopup(`Event route is ${importedRouteTotalLength.toFixed(2)} kilometers long.`); f.addLayer(r); setupRouteIcons(i[0], i[i.length - 1], r, f); let e = document.getElementById("line-chart"); e !== null && (e.style.display = "block", new Chart(document.getElementById("line-chart"), { type: "line", data: { labels: xAxisChartData, datasets: [{ data: yAxisChartData, label: "Elevation", borderColor: "#fcba03", fill: !0 }] }, options: { title: { display: !0, text: "Elevation Profile" }, scales: { xAxes: [{ display: !0 }] } } })) } function generateRandomColor() { let n = Math.random() * 16777215; n = Math.floor(n); n = n.toString(16); let t = n.padStart(6, 0); return `#${t.toUpperCase()}` } async function startConnection() { try { await connection.start() } catch (n) { setTimeout(() => startConnection(), 5e3) } } function setupParticipantsExistingPaths(n, t, i) { t.eachLayer(function (t) { if (n.participantId === t.options.id) for (let i = 0; i < n.currentParticipantPathPoints.length; i++) { let r = n.currentParticipantPathPoints[i]; t.addLatLng(L.latLng(r[0], r[1], r[2])) } }); i.eachLayer(function (t) { n.participantId === t.options.id && t.setLatLng(n.currentParticipantPathPoints[n.currentParticipantPathPoints.length - 1]) }) } function setupSidebarAndMapElements(n, t, i, r, u) { let f = generateRandomColor(), e = t; e.style.color = f; let o = e.id, s = L.marker([n[0], n[1]], { id: o }), h = new L.Polyline(new L.LatLng(n[0], n[1]), { id: o, color: f, weight: 2, smoothFactor: 1, fillOpacity: .5 }); i.addLayer(h); r.addLayer(s); u.addEventListener("change", n => { let t = n.target.id; n.target.checked ? (i.eachLayer(function (n) { t === n.options.id && (n._path.style.display = "block") }), r.eachLayer(function (n) { t === n.options.id && (n._icon.style.display = "block", n._shadow.style.display = "block") })) : (i.eachLayer(function (n) { t === n.options.id && (n._path.style.display = "none") }), r.eachLayer(function (n) { t === n.options.id && (n._icon.style.display = "none", n._shadow.style.display = "none") })) }) } function onBroadcast(n, t, i) { t.eachLayer(function (t) { n.participantId === t.options.id && t.addLatLng(L.latLng(n.latitude, n.longitude, n.altitude)) }); i.eachLayer(function (t) { n.participantId === t.options.id && t.setLatLng([n.latitude, n.longitude]) }); let r = document.getElementById(`${n.participantId}-current-location`); r.children[2].textContent = `Lat: ${n.latitude.toFixed(4)}`; r.children[4].textContent = `Lng: ${n.longitude.toFixed(4)}`; r.children[6].textContent = `Alt: ${n.altitude.toFixed(2)} m`; r.children[8].textContent = `Speed: ${n.speed.toFixed(2)} km/h` } function handleBroadcast(n, t, i, r, u) { let f = L.layerGroup(), e = L.layerGroup(), o = document.getElementsByClassName("random"), s = document.querySelectorAll('input[type="checkbox"]'), h = L.control.sidebar({ autopan: !0, closeButton: !0, container: "sidebar", position: "left" }).addTo(map); drawImportedRoute(t); for (let n = 0; n < r; n++)setupSidebarAndMapElements(i, o[n], f, e, s[n]); editableLayers.addLayer(f); editableLayers.addLayer(e); f.eachLayer(function (n) { n.addLatLng(L.latLng(i[0], i[1])) }); for (let t = 0; t < n.length; t++)n[t].currentParticipantPathPoints.length > 0 && setupParticipantsExistingPaths(n[t], f, e); startConnection(); connection.onclose(async () => { await startConnection() }); connection.on("BroadcastData", n => { n.eventId === u && onBroadcast(n, f, e) }) } let center = [42.6194, 25.393], map = L.map("map", { fullscreenControl: !0, fullscreenControlOptions: { position: "topleft" }, visualClick: !0, visualClickPane: "shadowPane" }).setView(center, 7); L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 18, attribution: '&copy; <a href="https://osm.org/copyright">OpenStreetMap<\/a> | &copy; <a href="https://opentopomap.org/about">OpenTopoMap<\/a> | &copy; <a href="/">Trails<\/a>' }).addTo(map); let editableLayers = new L.FeatureGroup; map.addLayer(editableLayers); L.control.mousePosition().addTo(map); L.control.scale().addTo(map); L.Control.Watermark = L.Control.extend({ onAdd: function () { let n = L.DomUtil.create("img"); return n.src = "/images/map/watermark.png", n.style.width = "130px", n } }); L.control.watermark = function (n) { return new L.Control.Watermark(n) }; L.control.watermark({ position: "topright" }).addTo(map); let importedRoutePoints = [], importedRouteTotalLength = 0, minAltitude = 0, maxAltitude = 0, altitudes = [], yAxisChartData = [], xAxisChartData = [], isUploadButtonClicked = !1; const connection = (new signalR.HubConnectionBuilder).withUrl("/live-feed").configureLogging(signalR.LogLevel.None).build();